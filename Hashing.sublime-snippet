<snippet>
	<content><![CDATA[
const ll N = 1e6 + 5;
ll modInverse(ll a, ll m) // calculates inverse modulo
{
    ll m0 = m, y = 0, x = 1;
    if (m == 1)
        return 0;
    while (a > 1)
    {
        ll q = a / m;
        ll t = m;
        m = a % m, a = t;
        t = y;
        y = x - q * y;
        x = t;
    }
    if (x < 0)
        x += m0;
    return x;
}

ll p_pow[2][N];
ll modIn[2][N];
const ll p[2] = {29, 31};
const ll m[2]={715225741, 1000000007};

void powCalc()
{
    p_pow[0][0] = 1;
    p_pow[1][0] = 1;
    for (ll i = 1; i < N; i++)
    {
        p_pow[0][i] = (p[0] * p_pow[0][i - 1]) % m[0];
        p_pow[1][i] = (p[1] * p_pow[1][i - 1]) % m[1];
        modIn[0][i]  =  modInverse(p_pow[0][i], m[0]);
        modIn[1][i]  =  modInverse(p_pow[1][i], m[1]);
    }
}

struct Hash
{
    ll n;
    string s;
    vector<ll> h, bh;
    
    Hash() {}
    Hash(string s, ll id) : s(s) {
        n = (ll)s.size();
        h.resize(n);
        bh.resize(n);
        
        h[0] = s[0] - 'a' + 1;
        for (ll i = 1; i < n; i++)
        {
            h[i] = (h[i-1] + (s[i] - 'a' + 1) * p_pow[id][i]) % m[id];
        }
        
        bh[n-1] = s[n-1] - 'a' + 1;
        for (ll i = n-2, j = 1; i >= 0; i--, j++)
        {
            bh[i] = (bh[i + 1] + (s[i] - 'a' + 1) * p_pow[id][j]) % m[id];
        }
    }
    
    ll query(ll l, ll r, ll id)
    {
        if (r < l)
            return 0;
        if (l == 0)
            return h[r];
        else
            return ((((h[r] - h[l-1]) + m[id]) % m[id]) * modIn[id][l]) % m[id];
    }
    
    ll merge(ll l1, ll r1, ll l2, ll r2, ll id) 
    {
        return (query(l1, r1, id) + query(l2, r2, id) * p_pow[id][r1 - l1 + 1]) % m[id];
    }
    
    ll back_query(ll l, ll r, ll id)
    {
        if (r < l)
            return 0;
        if (r == n-1)
            return bh[l];
        else
            return ((((bh[l] - bh[r + 1]) + m[id]) % m[id]) * modIn[id][n-1-r]) % m[id];
    }
};

// Hash h0(s, 0);
// Hash h1(s, 1);
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>Hashing</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
